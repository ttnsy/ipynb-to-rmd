# Classification: Prediksi Aktifitas Kapal

## Background

Memprediksi aktivitas suatu kapal berdasarkan kondisi/keadaan kapal saat melaut termasuk ke dalam salah satu kasus klasifikasi. Beberapa contoh kasus klasifikasi lainnya:

- Spam classifier: memprediksi apakah email yang masuk dikategorikan sebagai email spam atau buka spam
- Predicting loan default: memprediksi apakah nasabah/debitur termasuk yang akan gagal membayar kredit (default) atau sebaliknya
- Predicting customer churn: memprediksi apakah pelanggan akan berhenti berlangganan atau tidak
- dll.

Sama halnya saat melakukan analisis regresi, untuk melakukan klasifikasi diperlukan faktor eksternal (prediktor) yang secara informatif dapat menggambarkan pola dari setiap kategori. Prediktor (X) tersebut dapat berupa:

- Varibel bertipe numerik (angka)
- Variabel kategorik

Metode klasifikasi tidak secara eksplisit memprediksi suatu kategori, melainkan menggunakan nilai peluang (kemungkinan) yang diperoleh dari setiap kategori untuk mengklasifikasikan suatu observasi. Pada kasus binary classificaton (dimana target variabel hanya memiliki 2 kategori), jika peluang kelas positif yang diperoleh semakin mendekati 1, maka akan diklasifikasikan sebagai kelas positif. Sedangkan, jika peluang kelas positif yang diperoleh semakin mendekati 0, maka akan diprediksi sebagai kelas negatif. Batasan nilai peluang (threshold) yang umum digunakan adalah 0.5, contoh:

Dari hasil prediksi diperoleh peluang suatu email dikategorikan sebagai spam sebesar 0.7, maka email tersebut akan diprediksi sebagai email spam.

Sementara, pada kasus multiclass classification (dimana target variabel memiliki lebih dari 2 kategori), maka suatu observasi akan diklasifikasikan ke dalam suatu kelas berdasarkan nilai peluang tertinggi yang diperoleh untuk setiap kelas, contoh:

Dari hasil prediksi diperoleh suatu berita dikategorikan sebagai berita dengan sentimen positif adalah 0.5, negatif adalah 0.2, dan netral adalah 0.3. Maka, berita tersebut akan diprediksi sebagai berita dengan sentimen positif.


Studi kasus yang dimiliki KKP untuk model *classification* ini adalah untuk memprediksi aktifitas kapal, yaitu:

- `T`: *Transshipment*
- `M`: *Moving*
- `F`: *Fishing*
- `P`: *Port*

Adapun prediktor yang digunakan untuk model akan dibahas lebih dalam pada bab selanjutnya.

## Library & Setup

Untuk *library* yang akan digunakan pada permodelan ini antara lain:

- `pandas`: untuk proses manipulasi data.
- `numpy`: untuk pengolahan data numerik.
- `sklearn`: untuk membuat permodelan *machine learning*.
- `imblearn`: untuk mengatasi target yang *imbalance*.

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math

from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, confusion_matrix,plot_confusion_matrix, classification_report

from imblearn.over_sampling import SMOTE
from collections import Counter

from IPython.display import Image  
from sklearn import tree
import pydotplus

import warnings
warnings.filterwarnings('ignore')

np.random.seed(0)
```

## Data Cleaning

Data yang digunakan untuk studi kasus ini adalah `sampel_olah.csv`, yang merupakan data *tracking* dari 25 kapal yang berlayar pada tanggal 25 hingga 30 November 2020 di Laut Arafura:

```{python}
# read data
df = pd.read_csv("data/sampel_olah.csv")
df.head()
```

Sebagai tahapan awal, dilakukan proses *cleaning data* yang mencakup:

- Pengeliminasian nilai NA/kosong
- Pengaturan konsistensi nama kolom
- Penyesuaian tipe data dari setiap kolom
- Penyederhanaan kategori alat tangkap

```{python}
# drop na
df = df.dropna()

# colnames consistency
column_dict = {"Lon": "lon",
               "id_vesse": "id_vessel",
               "Act": "act"}

df = df.rename(columns=column_dict)

# adjust dtypes
df.tanggal = pd.to_datetime(df.tanggal)
df.alat_tangk = pd.Categorical(df.alat_tangk)
df.act = pd.Categorical(df.act)

# simplify categories
# # map categories: {v: k for k, v in dict(enumerate(df['alat_tangk'].cat.categories)).items()}

alattangk_dict = {'Bouke ami': 0,
 'Jala jatuh berkapal': 1,
 'Jaring insang oseanik': 2,
 'Jaring liong bun': 3,
 'Pancing Cumi (squid jigging)': 4,
 'Pancing Ulur': 5,
 'Pengangkut': 6,
 'Purse Seine (Pukat Cincin) Pelagis Kecil': 7,
 'Rawai dasar': 8}

df.alat_tangk = df.alat_tangk.replace(alattangk_dict)

df.head()
```

## Exploratory Data Analysis

### Category proportion

- Proporsi dari target (`act`):

```{python}
act = pd.crosstab(index = df.act,columns = 'Jumlah')
act['Proporsi'] = (act.Jumlah / act.Jumlah.sum()).map(lambda n: '{:,.2%}'.format(n))
act
```

<a id='note1'><b>*Note 1:</b></a>

Jika dilihat dari data, kemunculan nilai `T`/Transshipment pada target memiliki proporsi yang sangat sedikit, yaitu 113 dari 26577 atau hanya sebesar 0.43%. Karena itulah untuk menghindari bias pada model, perlu dilakukan proses *rebalancing* pada target. Proses tersebut akan dijabarkan lebih jauh pada sub-bab *Handling Imbalance Class*.

- Proporsi aktifitas kapal berdasarkan alat tangkap:

```{python}
df_alat = pd.crosstab(
    index = df.alat_tangk,
    columns = df.act
)

df_alat
```

<a id='note2'><b>*Note 2:</b></a>

Jika dilihat dari data, kejadian *Transshipment* hanya muncul pada kapal dengan alat tangkap 6 (Pengangkut). Hal tersebut juga dapat mempengaruhi bagaimana model akan mengambil keputusan.

### Activity Trend by Hour

```{python}
pd.crosstab(
    index = df.tanggal.dt.hour,
    columns = df.act,
    normalize = 'index'
).plot()
```

Dari grafik diatas, ditemukan adanya pola tertentu dalam aktifitas *Fishing*, yaitu pada sekitar pukul 12 malam hingga 8 pagi.

## Feature Engineering & Selection

Pada tahapan ini, akan dilakukan penyeleksian & pengolahan dari fitur atau kolom-kolom yang akan dijadikan prediktor pada model. 

Variabel yang dipertahankan antara lain:

- Titik lokasi kapal*: `lat` & `lon`
- Informasi kapal: `spd`, `heading`, `power`, `ukuran_gt` & `alat_tangk`

Adapun beberapa variabel yang dibuang dan ditambahkan:

- Penambahan `hour`: informasi jam dari kapal berlayar.
- Pengeliminasian `id_vessel` & `tanggal`


<a id='note2'><b>*Note 3:</b></a>

1. Dikarenakan titik latitude & longitude dari kapal digunakan secara eksplisit, maka model yang dibuat hanya dapat menangkap pola lokasi dari area yang digunakan saat *fitting* model. Untuk area lainnya, perlu untuk dilakukan *retrain* model agar dapat menangkap pola lokasi berdasarkan area tersebut.

2. Opsi lainnya adalah untuk membuat prediktor baru yang mengindikasikan informasi yang lebih spesifik. Misal: jarak ke Port, dsb. Untuk dapat mengimplementasikan poin ini, maka dibutuhkan data tambahan berupa lokasi dari seluruh Port.

```{python}
df['hour'] = df.tanggal.dt.hour
df = df.drop(['id_vessel','tanggal'],axis=1)

df.info()
```

## Modelling

### Preparation

Sebelum dilakukan proses *fitting* model, data di persiapkan terlebih dahulu untuk dilakukan permodelan. Adapun proses yang dilakukan pada tahapan ini adalah:

- **Dummy Variable**: Mengkuantifikasi nilai yang kategorik. Nilai yang bersifat kategorik akan ditransformasi menjadi kolom dengan nilai biner (1 atau 0).
- **Cross Validation**: Membagi data menjadi *train* dan *test*. Data *train* akan digunakan untuk model belajar, sementara data *test* akan digunakan untuk menguji performa model.
- **Handling Imbalance Class**: Melakukan *rebalancing* pada jumlah target agar model tidak bias dalam memprediksi kategori target.

#### Dummy Variable

```{python}
df = pd.concat(
    [df.drop("alat_tangk",axis=1),
    pd.get_dummies(df.alat_tangk, prefix='alat_')],
    axis=1
)

df.head()
```

#### Cross Validation

```{python}
from sklearn.model_selection import train_test_split

x_col = df.loc[:, df.columns != 'act'].columns
x = df[x_col]
y = df['act']

X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=0, stratify = y)
```

```{python}
print(X_train.shape, X_test.shape, y_train.shape, y_test.shape)
```

#### Handling Imbalance Class

```{python}
smt = SMOTE(random_state=0)
X_train, y_train = smt.fit_sample(X_train, y_train)
```

```{python}
print(X_train.shape, y_train.shape)
```

#### Scaling (for k-NN only)

```{python}
from sklearn.preprocessing import StandardScaler

sc = StandardScaler()
X_train_knn = sc.fit_transform(X_train[['lon', 'lat', 'spd', 'heading', 'power', 'ukuran_gt', 'hour']])
X_test_knn = sc.transform(X_test[['lon', 'lat', 'spd', 'heading', 'power', 'ukuran_gt', 'hour']])
```

### Multinomial Logistic Regression

#### Model Fitting

```{python}
import statsmodels.api as sm

# fitting model
logit_model = sm.MNLogit(y_train, sm.add_constant(X_train)).fit()

print(logit_model.summary())
```

#### Evaluation

##### Prediction

```{python}
# predict target for test dataset
prediction = logit_model.predict(sm.add_constant(X_test))
prediction.head()
```

Hasil prediksi berupa peluang untuk setiap kelas yang harus diubah ke dalam bentuk kategori/kelas, dimana suatu observasi akan diprediksi masuk ke kelas tertentu berdasarkan nilai peluang tertinggi yang diperoleh.

```{python}
prediction['max_prob'] = prediction.max(axis=1)
prediction['label'] = np.select([prediction[0] == prediction.max_prob, 
                                 prediction[1] == prediction.max_prob, 
                                 prediction[2] == prediction.max_prob], 
                                ['F', 'M', 'P'], default = 'T')
prediction.head()
```

##### Evaluation

```{python}
accuracy_score(y_test, prediction['label'])
```

```{python}
confmtrx = np.array(confusion_matrix(y_test, prediction['label']))
pd.DataFrame(confmtrx, 
             index=['F','M', 'P', 'T'], 
             columns=['F','M', 'P', 'T'])
```

### k-NN

```{python}
# find optimum k
math.sqrt(X_train_knn.shape[0])
```

```{python}
from sklearn.neighbors import KNeighborsClassifier

# fitting model
knn = KNeighborsClassifier(n_neighbors=209).fit(X_train_knn, y_train) 

# predict target for test dataset
prediction = knn.predict(X_test_knn)
```

#### Evaluation

```{python}
accuracy_score(y_test, prediction)
```

```{python}
confmtrx = np.array(confusion_matrix(y_test, prediction))
pd.DataFrame(confmtrx, 
             index=['F','M', 'P', 'T'], 
             columns=['F','M', 'P', 'T'])
```

```{python}
print(classification_report(y_test, prediction))
```

### Decision Tree

#### Model Fitting

Agar model mudah diinterpretasikan, *decision tree* dibuat dengan `max_depth=4` atau memiliki kedalaman maksimal sebanyak 4 cabang:

```{python}
# model fitting
clf = DecisionTreeClassifier(criterion="entropy", max_depth=4)
clf = clf.fit(X_train,y_train)


# visualize decision tree
dot_data = tree.export_graphviz(clf, out_file=None, 
                                feature_names=x_col,  
                                class_names=['F','M','P','T'])
graph = pydotplus.graph_from_dot_data(dot_data)  
Image(graph.create_png())
```

Merujuk pada sub-bab *Exploratory Data Analysis* mengenai [proporsi aktifitas kapal berdasarkan alat tangkap](#note2), model `clf` pertama kali akan mengambil keputusan berdasarkan alat tangkap jenis 6 (Pengangkut). Ketika kapal tersebut memiliki alat tangkap dengan jenis tersebut, maka kapal memiliki kecenderungan untuk dikategorikan sebagai *Transshipment*.

#### Evaluation

```{python}
# Predict the response for test dataset
y_pred = clf.predict(X_test)

# Evaluate accuracy
accuracy_score(y_test, y_pred)
```

Bedasarkan pengujian pada data *test*, didapatkan nilai akurasi model sebesar 71%. Sedangkan nilai *Precision*, *Recall* dan *Confusion Matrix* dapat dilihat pada output berikut:

```{python}
# get precision & recall
print(classification_report(y_test, y_pred))

# plot confusion matrix
plot_confusion_matrix(clf, X_test, y_test,cmap='Blues')
```

Berdasarkan hasil diatas, diketahui jika model `clf` memiliki kelemahan dalam memprediksi kapal yang *Fishing*. Ada sebesar 1106 kapal yang seharusnya beraktifitas *Fishing* diprediksi sebagai *Moving*.

### Random Forest

#### Model Fitting

```{python}
forest = RandomForestClassifier(random_state = 1)
modelF = forest.fit(X_train, y_train)
```

#### Model Evaluation

```{python}
# predict
y_predF = modelF.predict(X_test)

# get precision & recall
print(classification_report(y_test, y_predF))

# plot confusion matrix
plot_confusion_matrix(modelF, X_test, y_test,cmap='Blues')
```

```{python}
features = x_col.values
importances = modelF.feature_importances_
indices = np.argsort(importances)

plt.title('Feature Importances')
plt.barh(range(len(indices)), importances[indices], color='b', align='center')
plt.yticks(range(len(indices)), [features[i] for i in indices])
plt.xlabel('Relative Importance')
plt.show()
```

## Kesimpulan

- Model `modelF` dengan menggunakan algoritma Random Forest memiliki performa terbaik dalam memprediksi aktifitas kapal dengan beberapa catatan:

    1. Sampel memiliki target yang sangat imbalance dalam mengkategorikan Transshipment (Lihat [*Note 1](#note1))
    2. `alat_6` masih termasuk variabel dengan tingkat Importance yang tinggi. Dikarenakan pada data sampel hanya `alat_6` yang dikategorikan sebagai Transshipment (Lihat [*Note 2](#note2)), perlu dipertimbangkan untuk menambah sampel dari kapal dengan alat tangkap lain yang memiliki kategori serupa.
    3. `modelF` hanya mampu menangkap pola latitude & longitude dari Laut Arafura. Untuk lokasi lainnya perlu dilakukan pembuatan model ulang dari data yang merujuk pada kapal dari lokasi tersebut. (Lihat [*Note 3](#note3))
    

